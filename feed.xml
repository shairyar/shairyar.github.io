<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://shairyar.github.io/</id><title>Shairyar Baig</title><subtitle>Hi there! My name is Shairyar Baig, I am a developer and I love tinkering with diferent programing languages &amp; hardware.</subtitle> <updated>2025-11-12T17:04:11+05:00</updated> <author> <name>Shairyar Baig</name> <uri>https://shairyar.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://shairyar.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://shairyar.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator> <rights> © 2025 Shairyar Baig </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Kubernetes Learning Path: Understanding Persistent Storage</title><link href="https://shairyar.github.io/posts/kubernetes-learning-path-persistent-storage/" rel="alternate" type="text/html" title="Kubernetes Learning Path: Understanding Persistent Storage" /><published>2025-11-12T10:00:00+05:00</published> <updated>2025-11-12T10:00:00+05:00</updated> <id>https://shairyar.github.io/posts/kubernetes-learning-path-persistent-storage/</id> <content type="text/html" src="https://shairyar.github.io/posts/kubernetes-learning-path-persistent-storage/" /> <author> <name>Shairyar Baig</name> </author> <category term="Kubernetes" /> <category term="Tutorial" /> <summary>Kubernetes Learning Path: Understanding Persistent Storage When I first started deploying applications on Kubernetes, I quickly ran into a problem: my database data kept disappearing every time a pod restarted. That’s when I realized I needed to understand persistent storage. In Kubernetes, pods are temporary—they can be created, destroyed, and recreated at any time. This is great for things ...</summary> </entry> <entry><title>Remote Access to Your k3s Homelab with Tailscale</title><link href="https://shairyar.github.io/posts/remote-access-to-k3s-homelab-with-tailscale/" rel="alternate" type="text/html" title="Remote Access to Your k3s Homelab with Tailscale" /><published>2025-11-09T10:00:00+05:00</published> <updated>2025-11-09T10:00:00+05:00</updated> <id>https://shairyar.github.io/posts/remote-access-to-k3s-homelab-with-tailscale/</id> <content type="text/html" src="https://shairyar.github.io/posts/remote-access-to-k3s-homelab-with-tailscale/" /> <author> <name>Shairyar Baig</name> </author> <category term="Kubernetes" /> <category term="Tutorial" /> <summary>Remote Access to Your k3s Homelab with Tailscale While working on my k3s homelab cluster, I ran into an interesting challenge: how could I access my cluster when I wasn’t home? I wanted to run kubectl commands from anywhere, manage my deployments remotely, and check on my applications—but I didn’t have a dedicated public IP address from my ISP. That’s when I discovered Tailscale. Tailscale i...</summary> </entry> <entry><title>Kubernetes Learning Path: Setting Up Ingress Controller for External Access</title><link href="https://shairyar.github.io/posts/kubernetes-learning-path-ingress-controller/" rel="alternate" type="text/html" title="Kubernetes Learning Path: Setting Up Ingress Controller for External Access" /><published>2025-11-06T09:00:00+05:00</published> <updated>2025-11-06T09:00:00+05:00</updated> <id>https://shairyar.github.io/posts/kubernetes-learning-path-ingress-controller/</id> <content type="text/html" src="https://shairyar.github.io/posts/kubernetes-learning-path-ingress-controller/" /> <author> <name>Shairyar Baig</name> </author> <category term="Kubernetes" /> <category term="Tutorial" /> <summary>Kubernetes Learning Path: Setting Up Ingress Controller for External Access After deploying my Rails application with PostgreSQL and SolidQueue workers in the previous post, I had a fully functional application running on my Raspberry Pi k3s cluster. But there was one problem: I could only access it using kubectl port-forward. Port-forwarding is fine for testing and debugging, but it’s not a ...</summary> </entry> <entry><title>Kubernetes Learning Path: Deploying Rails 8 with SolidQueue on Raspberry Pi k3s</title><link href="https://shairyar.github.io/posts/kubernetes-learning-path-rails-solidqueue-on-k3s/" rel="alternate" type="text/html" title="Kubernetes Learning Path: Deploying Rails 8 with SolidQueue on Raspberry Pi k3s" /><published>2025-10-31T14:00:00+05:00</published> <updated>2025-11-06T17:03:43+05:00</updated> <id>https://shairyar.github.io/posts/kubernetes-learning-path-rails-solidqueue-on-k3s/</id> <content type="text/html" src="https://shairyar.github.io/posts/kubernetes-learning-path-rails-solidqueue-on-k3s/" /> <author> <name>Shairyar Baig</name> </author> <category term="Kubernetes" /> <category term="Tutorial" /> <summary>Kubernetes Learning Path: Deploying Rails 8 with SolidQueue on Raspberry Pi k3s After setting up my 3-node Raspberry Pi k3s cluster in the previous post, I wanted to deploy something real—not just nginx demos, but an actual production-grade application. So I decided to deploy a Ruby on Rails 8 application with all the modern bells and whistles: PostgreSQL, background jobs with SolidQueue, data...</summary> </entry> <entry><title>Kubernetes Learning Path: Setting Up k3s on Raspberry Pi</title><link href="https://shairyar.github.io/posts/kubernetes-learning-path-k3s-on-raspberry-pi/" rel="alternate" type="text/html" title="Kubernetes Learning Path: Setting Up k3s on Raspberry Pi" /><published>2025-10-29T10:00:00+05:00</published> <updated>2025-10-29T10:00:00+05:00</updated> <id>https://shairyar.github.io/posts/kubernetes-learning-path-k3s-on-raspberry-pi/</id> <content type="text/html" src="https://shairyar.github.io/posts/kubernetes-learning-path-k3s-on-raspberry-pi/" /> <author> <name>Shairyar Baig</name> </author> <category term="Kubernetes" /> <category term="Tutorial" /> <summary>Kubernetes Learning Path: Setting Up k3s on Raspberry Pi After going through the first four parts of this series with k3d, I felt ready to take things to the next level. k3d is great for learning and local development, but there’s something different about running Kubernetes on actual hardware. You deal with real networking, real resource constraints, and real high availability scenarios that ...</summary> </entry> </feed>
