<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Kubernetes Learning Path: Understanding Persistent Storage" /><meta property="og:locale" content="en" /><meta name="description" content="Kubernetes Learning Path: Understanding Persistent Storage" /><meta property="og:description" content="Kubernetes Learning Path: Understanding Persistent Storage" /><link rel="canonical" href="https://shairyar.github.io/posts/kubernetes-learning-path-persistent-storage/" /><meta property="og:url" content="https://shairyar.github.io/posts/kubernetes-learning-path-persistent-storage/" /><meta property="og:site_name" content="Shairyar Baig" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-11-12T10:00:00+05:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Kubernetes Learning Path: Understanding Persistent Storage" /><meta name="twitter:site" content="@iamshairyar" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-11-12T10:00:00+05:00","datePublished":"2025-11-12T10:00:00+05:00","description":"Kubernetes Learning Path: Understanding Persistent Storage","headline":"Kubernetes Learning Path: Understanding Persistent Storage","mainEntityOfPage":{"@type":"WebPage","@id":"https://shairyar.github.io/posts/kubernetes-learning-path-persistent-storage/"},"url":"https://shairyar.github.io/posts/kubernetes-learning-path-persistent-storage/"}</script><title>Kubernetes Learning Path: Understanding Persistent Storage | Shairyar Baig</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Shairyar Baig"><meta name="application-name" content="Shairyar Baig"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.32.2/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script src="/assets/js/dist/theme.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.13/dayjs.min.js,npm/dayjs@1.11.13/locale/en.js,npm/dayjs@1.11.13/plugin/relativeTime.js,npm/dayjs@1.11.13/plugin/localizedFormat.js,npm/tocbot@4.32.2/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-3MSE8F2TRT"></script> <script> document.addEventListener('DOMContentLoaded', () => { window.dataLayer = window.dataLayer || []; function gtag() { dataLayer.push(arguments); } gtag('js', new Date()); gtag('config', 'G-3MSE8F2TRT'); }); </script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="https://pbs.twimg.com/profile_images/1531277756490825728/myc7uFj__400x400.jpg" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/">Shairyar Baig</a><p class="site-subtitle fst-italic mb-0">tinkering with stuff</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/shairyar" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/iamshairyar" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['shairyarbaig','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>Kubernetes Learning Path: Understanding Persistent Storage</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link" aria-label="Search"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1" data-toc="true"><header><h1 data-toc-skip>Kubernetes Learning Path: Understanding Persistent Storage</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1762923600" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Nov 12, 2025 </time> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/iamshairyar">Shairyar Baig</a> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="2230 words" > <em>12 min</em> read</span></div></div></div></header><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">Kubernetes Learning Path: Understanding Persistent Storage</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">Contents</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div class="header d-flex flex-row align-items-center justify-content-between"><div class="label text-truncate py-2 ms-4">Kubernetes Learning Path: Understanding Persistent Storage</div><button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"> <i class="fas fa-close"></i> </button></div><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><h1 id="kubernetes-learning-path-understanding-persistent-storage">Kubernetes Learning Path: Understanding Persistent Storage</h1><p>When I first started deploying applications on Kubernetes, I quickly ran into a problem: my database data kept disappearing every time a pod restarted. That’s when I realized I needed to understand persistent storage.</p><p>In Kubernetes, pods are temporary—they can be created, destroyed, and recreated at any time. This is great for things like web servers that don’t need to remember anything. But what about databases? They need to remember all your data even when the pod restarts. That’s where persistent storage comes in.</p><p>In this post, I’ll walk you through how to set up persistent storage in Kubernetes. We’ll use something called a PersistentVolumeClaim (or PVC for short—think of it as asking for storage) and a StatefulSet (which is like a special type of pod that can use storage). We’ll use a PostgreSQL database as our example.</p><h2 id="why-persistent-storage-matters"><span class="me-2">Why Persistent Storage Matters</span><a href="#why-persistent-storage-matters" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>If you deploy a PostgreSQL database using a regular Deployment, every time the pod restarts or gets recreated, all your data disappears. The container’s filesystem is temporary. It only exists for the lifetime of the pod, and when that pod dies, so does everything inside it.</p><p>Persistent storage fixes this. Your data survives pod restarts, which means databases and other stateful applications actually work the way they’re supposed to. You can also move data between nodes when needed.</p><h2 id="the-components-pvc-and-pv"><span class="me-2">The Components: PVC and PV</span><a href="#the-components-pvc-and-pv" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Before jumping into the configuration, here’s what you need to know:</p><p><strong>PersistentVolume (PV):</strong> This is the actual storage space in your cluster. Think of it like a real hard drive that exists somewhere. Someone (either an admin or Kubernetes itself) sets this up.</p><p><strong>PersistentVolumeClaim (PVC):</strong> This is you asking for storage. It’s like going to a restaurant and saying “I need a table for 4 people.” You’re making a request. You tell Kubernetes “I need 5 gigabytes of storage” and Kubernetes finds or creates the actual storage (the PV) for you.</p><p>Here’s how it works: You create a PVC (this is the configuration you provide). Kubernetes reads your PVC configuration and uses it to automatically create the actual storage (the PV). You don’t manually create PVs—you just provide the PVC configuration, and Kubernetes handles creating the PV for you. But remember: if you don’t provide a PVC configuration first, Kubernetes won’t create any storage. The PVC configuration is what tells Kubernetes what storage to create.</p><h2 id="setting-up-persistent-storage-for-postgresql"><span class="me-2">Setting Up Persistent Storage for PostgreSQL</span><a href="#setting-up-persistent-storage-for-postgresql" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>I’ll walk through a complete PostgreSQL setup with persistent storage. I’ll go through each configuration file and explain what’s happening.</p><h3 id="1-persistentvolumeclaim-pvc"><span class="me-2">1. PersistentVolumeClaim (PVC)</span><a href="#1-persistentvolumeclaim-pvc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>First up, we need to request storage. Here’s the PVC:</p><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">PersistentVolumeClaim</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">postgres-pvc</span>              <span class="c1"># Name of this PVC resource - we'll use this exact name in the StatefulSet below to connect them</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">default</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">accessModes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">ReadWriteOnce</span>                <span class="c1"># Volume can be mounted read-write by a single node</span>
  <span class="na">resources</span><span class="pi">:</span>
    <span class="na">requests</span><span class="pi">:</span>
      <span class="na">storage</span><span class="pi">:</span> <span class="s">5Gi</span>                 <span class="c1"># Requesting 5 gigabytes of storage</span>
</pre></table></code></div></div><p>The important parts here:</p><ul><li><strong><code class="language-plaintext highlighter-rouge">name: postgres-pvc</code>:</strong> This is the name we’re giving to this storage resource. The StatefulSet (which contains the PostgreSQL database pod) will use this exact name to connect to this storage. Think of the PVC as the hard drive, and the StatefulSet as the computer that needs to use that hard drive. We’ll reference this name in the StatefulSet configuration below.<li><strong><code class="language-plaintext highlighter-rouge">accessModes: ReadWriteOnce</code>:</strong> This means only one computer (node) can use this storage at a time, and it can both read and write. This is perfect for databases. There are other options (like letting multiple computers use it), but for databases, you almost always want ReadWriteOnce.<li><strong><code class="language-plaintext highlighter-rouge">storage: 5Gi</code>:</strong> We’re asking for 5 gigabytes. Change this to whatever you actually need.</ul><h3 id="2-statefulset-for-postgresql"><span class="me-2">2. StatefulSet for PostgreSQL</span><a href="#2-statefulset-for-postgresql" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>For databases and other apps that need to remember things, you need a StatefulSet, not a regular Deployment. The main difference? StatefulSets can use persistent storage, and they give each pod a stable name that doesn’t change. This is important for databases.</p><p>Here’s the StatefulSet:</p><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">StatefulSet</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">postgres</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">default</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">serviceName</span><span class="pi">:</span> <span class="s">postgres</span>            <span class="c1"># This name must match the Service name we'll create below (connects StatefulSet to Service)</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">1</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">postgres</span>                 <span class="c1"># This label must match the label in the pod template below (in this same file)</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">postgres</span>               <span class="c1"># This label must match the selector above (in this same file) and the Service selector below</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">postgres</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">postgres:15-alpine</span>
        <span class="na">ports</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">5432</span>
          <span class="na">name</span><span class="pi">:</span> <span class="s">postgres</span>
        <span class="na">envFrom</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">secretRef</span><span class="pi">:</span>
            <span class="na">name</span><span class="pi">:</span> <span class="s">postgres-secret</span>   <span class="c1"># References the Secret created earlier (loads all keys as env vars)</span>
        <span class="na">volumeMounts</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">postgres-storage</span>    <span class="c1"># This name must match the volume name in the volumes section below (in this same file)</span>
          <span class="na">mountPath</span><span class="pi">:</span> <span class="s">/var/lib/postgresql/data</span>  <span class="c1"># Where PostgreSQL stores its data inside the container</span>
          <span class="na">subPath</span><span class="pi">:</span> <span class="s">postgres</span>         <span class="c1"># Creates a subdirectory to prevent permission issues</span>
        <span class="na">resources</span><span class="pi">:</span>
          <span class="na">requests</span><span class="pi">:</span>
            <span class="na">memory</span><span class="pi">:</span> <span class="s2">"</span><span class="s">256Mi"</span>
            <span class="na">cpu</span><span class="pi">:</span> <span class="s2">"</span><span class="s">250m"</span>
          <span class="na">limits</span><span class="pi">:</span>
            <span class="na">memory</span><span class="pi">:</span> <span class="s2">"</span><span class="s">512Mi"</span>
            <span class="na">cpu</span><span class="pi">:</span> <span class="s2">"</span><span class="s">500m"</span>
        <span class="na">livenessProbe</span><span class="pi">:</span>
          <span class="na">exec</span><span class="pi">:</span>
            <span class="na">command</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="s">pg_isready</span>
            <span class="pi">-</span> <span class="s">-U</span>
            <span class="pi">-</span> <span class="s">$(POSTGRES_USER)</span>      <span class="c1"># Uses environment variable from postgres-secret</span>
            <span class="pi">-</span> <span class="s">-d</span>
            <span class="pi">-</span> <span class="s">$(POSTGRES_DB)</span>        <span class="c1"># Uses environment variable from postgres-secret</span>
          <span class="na">initialDelaySeconds</span><span class="pi">:</span> <span class="m">30</span>
          <span class="na">periodSeconds</span><span class="pi">:</span> <span class="m">10</span>
        <span class="na">readinessProbe</span><span class="pi">:</span>
          <span class="na">exec</span><span class="pi">:</span>
            <span class="na">command</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="s">pg_isready</span>
            <span class="pi">-</span> <span class="s">-U</span>
            <span class="pi">-</span> <span class="s">$(POSTGRES_USER)</span>      <span class="c1"># Uses environment variable from postgres-secret</span>
            <span class="pi">-</span> <span class="s">-d</span>
            <span class="pi">-</span> <span class="s">$(POSTGRES_DB)</span>        <span class="c1"># Uses environment variable from postgres-secret</span>
          <span class="na">initialDelaySeconds</span><span class="pi">:</span> <span class="m">5</span>
          <span class="na">periodSeconds</span><span class="pi">:</span> <span class="m">5</span>
      <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">postgres-storage</span>      <span class="c1"># This name must match the volumeMounts.name above (in this same file) - connects the volume to the mount</span>
        <span class="na">persistentVolumeClaim</span><span class="pi">:</span>
          <span class="na">claimName</span><span class="pi">:</span> <span class="s">postgres-pvc</span>   <span class="c1"># This is the name from the PVC we created earlier - connects this StatefulSet to that storage</span>
</pre></table></code></div></div><p>A few things to note:</p><p><strong><code class="language-plaintext highlighter-rouge">serviceName: postgres</code>:</strong> This tells the StatefulSet to use a headless service (we’ll create that next) for stable network identity.</p><p><strong><code class="language-plaintext highlighter-rouge">volumeMounts</code>:</strong> This is where we connect the storage to the container. The <code class="language-plaintext highlighter-rouge">mountPath</code> is just a folder path inside the container where PostgreSQL will save its data (<code class="language-plaintext highlighter-rouge">/var/lib/postgresql/data</code> is PostgreSQL’s default data folder). The <code class="language-plaintext highlighter-rouge">subPath: postgres</code> part creates a subfolder inside the storage—this prevents permission problems. I learned this the hard way when PostgreSQL couldn’t write to the storage because of permission issues.</p><p><strong><code class="language-plaintext highlighter-rouge">volumes</code>:</strong> This is where we tell the StatefulSet which storage to use. We reference the PVC name (<code class="language-plaintext highlighter-rouge">postgres-pvc</code>) that we created earlier. This connects the storage to the container.</p><p><strong>Health checks:</strong> These check if PostgreSQL is actually working, not just if the container is running. They use <code class="language-plaintext highlighter-rouge">pg_isready</code> which is a PostgreSQL command. Notice we’re using <code class="language-plaintext highlighter-rouge">$(POSTGRES_USER)</code> and <code class="language-plaintext highlighter-rouge">$(POSTGRES_DB)</code>—these are environment variables that come from the Secret. This way, if we change the Secret, the health checks automatically use the new values.</p><h3 id="3-headless-service"><span class="me-2">3. Headless Service</span><a href="#3-headless-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>StatefulSets need a special type of service called a “headless service.” A normal service gives pods a single IP address to share, but a headless service doesn’t—it lets each pod have its own address. This is important for StatefulSets because each pod needs its own identity. Here’s what it looks like:</p><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">postgres</span>                   <span class="c1"># This name must match the StatefulSet spec.serviceName above (connects Service to StatefulSet)</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">default</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">postgres</span>                  <span class="c1"># This label must match the label in StatefulSet template.metadata.labels above (connects Service to pods)</span>
  <span class="na">ports</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">port</span><span class="pi">:</span> <span class="m">5432</span>                     <span class="c1"># Port exposed by the service</span>
    <span class="na">targetPort</span><span class="pi">:</span> <span class="m">5432</span>               <span class="c1"># Port on the container (matches containerPort in StatefulSet)</span>
  <span class="na">clusterIP</span><span class="pi">:</span> <span class="s">None</span>                  <span class="c1"># Headless service - required for StatefulSets</span>
</pre></table></code></div></div><p>The <code class="language-plaintext highlighter-rouge">clusterIP: None</code> is what makes it “headless”—it means there’s no shared IP address. Instead, each pod gets its own address, which is what StatefulSets need.</p><h3 id="4-secret-for-database-credentials"><span class="me-2">4. Secret for Database Credentials</span><a href="#4-secret-for-database-credentials" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>We’ll store the database credentials in a Secret (I covered this in <a href="/posts/kubernetes-learning-path-configmaps-and-secrets/">Part 2</a>):</p><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Secret</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">postgres-secret</span>             <span class="c1"># This name is referenced in StatefulSet envFrom.secretRef</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">default</span>
<span class="na">type</span><span class="pi">:</span> <span class="s">Opaque</span>
<span class="na">stringData</span><span class="pi">:</span>
  <span class="c1"># PostgreSQL initialization variables (used by postgres image)</span>
  <span class="na">POSTGRES_USER</span><span class="pi">:</span> <span class="s">rails_user</span>
  <span class="na">POSTGRES_PASSWORD</span><span class="pi">:</span> <span class="s">secure_password_change_me</span>
  <span class="na">POSTGRES_DB</span><span class="pi">:</span> <span class="s">myapp_production</span>
</pre></table></code></div></div><h2 id="how-these-pieces-fit-together"><span class="me-2">How These Pieces Fit Together</span><a href="#how-these-pieces-fit-together" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Before we deploy, let me explain how these three components connect to each other. Think of it like this:</p><p><strong>PersistentVolumeClaim (PVC)</strong> = Your storage (like a hard drive)<br /> <strong>StatefulSet</strong> = Your PostgreSQL database pod (the computer that needs the hard drive)<br /> <strong>Service</strong> = The way other pods can find and talk to your database</p><p>Here’s how they link together:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre>┌─────────────────┐
│   Service       │  ← Gives your database a stable address
│   (postgres)    │     so other pods can find it
└────────┬────────┘
         │ (finds pods by label: app=postgres)
         │
         ▼
┌─────────────────┐
│  StatefulSet    │  ← Your PostgreSQL database pod
│  (postgres)     │     - Uses Service name: "postgres" (connects to Service above)
└────────┬────────┘     - Has label: app=postgres (Service uses this to find it)
         │
         │ (uses PVC name: "postgres-pvc")
         ▼
┌─────────────────┐
│      PVC        │  ← Your storage (where database saves data)
│  (postgres-pvc) │
└─────────────────┘
</pre></table></code></div></div><p>In simple terms:</p><ol><li><strong>StatefulSet connects to PVC</strong>: The StatefulSet says “I need storage” and uses the PVC name <code class="language-plaintext highlighter-rouge">postgres-pvc</code> to get it. This is like plugging a hard drive into your computer.<li><strong>Service connects to StatefulSet</strong>: The Service helps other pods find your database. It looks for pods with the label <code class="language-plaintext highlighter-rouge">app=postgres</code> (which is what the StatefulSet creates). Also, the Service name must be <code class="language-plaintext highlighter-rouge">postgres</code> because that’s what the StatefulSet is looking for.<li><strong>Everything stays in sync</strong>: When the StatefulSet creates a pod, that pod has the label <code class="language-plaintext highlighter-rouge">app=postgres</code>, so the Service automatically finds it. The pod also gets the storage from the PVC, so your data persists.</ol><p>It’s like a chain: Service → finds → StatefulSet pods → uses → PVC storage.</p><h2 id="deploying-everything"><span class="me-2">Deploying Everything</span><a href="#deploying-everything" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>With all the pieces ready, time to deploy:</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c"># Apply all configurations</span>
kubectl apply <span class="nt">-f</span> postgres-secret.yaml
kubectl apply <span class="nt">-f</span> postgres-pvc.yaml
kubectl apply <span class="nt">-f</span> postgres-service.yaml
kubectl apply <span class="nt">-f</span> postgres-statefulset.yaml
</pre></table></code></div></div><p>Or if all files are in the same directory:</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>kubectl apply <span class="nt">-f</span> postgres-secret.yaml postgres-pvc.yaml postgres-service.yaml postgres-statefulset.yaml
</pre></table></code></div></div><h2 id="verifying-the-setup"><span class="me-2">Verifying the Setup</span><a href="#verifying-the-setup" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Check that everything is working:</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c"># Check the PVC status</span>
kubectl get pvc

<span class="c"># Output should show:</span>
<span class="c"># NAME           STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span>
<span class="c"># postgres-pvc   Bound    pvc-xxx  5Gi        RWO            local-path     10s</span>
</pre></table></code></div></div><p>You should see <code class="language-plaintext highlighter-rouge">STATUS</code> as <code class="language-plaintext highlighter-rouge">Bound</code>—that means your request for storage was successful! Kubernetes found or created the actual storage and connected it to your PVC. If it says “Pending,” something went wrong.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c"># Check the StatefulSet and pods</span>
kubectl get statefulset
kubectl get pods <span class="nt">-l</span> <span class="nv">app</span><span class="o">=</span>postgres

<span class="c"># Check pod details to see the volume mount</span>
kubectl describe pod postgres-0
</pre></table></code></div></div><p>In the pod description, look for the volume mount under <code class="language-plaintext highlighter-rouge">Mounts:</code>. If you see it listed there, that means the storage is actually connected to your pod and ready to use.</p><h2 id="testing-persistence"><span class="me-2">Testing Persistence</span><a href="#testing-persistence" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The real test is whether your data actually survives a pod restart. Here’s how to verify:</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c"># Connect to the database and create some test data</span>
kubectl <span class="nb">exec</span> <span class="nt">-it</span> postgres-0 <span class="nt">--</span> psql <span class="nt">-U</span> rails_user <span class="nt">-d</span> myapp_production

<span class="c"># Inside psql:</span>
CREATE TABLE test_persistence <span class="o">(</span><span class="nb">id </span>SERIAL PRIMARY KEY, message TEXT<span class="o">)</span><span class="p">;</span>
INSERT INTO test_persistence <span class="o">(</span>message<span class="o">)</span> VALUES <span class="o">(</span><span class="s1">'This should persist!'</span><span class="o">)</span><span class="p">;</span>
SELECT <span class="k">*</span> FROM test_persistence<span class="p">;</span>
<span class="se">\q</span>
</pre></table></code></div></div><p>Now delete the pod and watch Kubernetes recreate it:</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c"># Delete the pod</span>
kubectl delete pod postgres-0

<span class="c"># Watch it get recreated</span>
kubectl get pods <span class="nt">-l</span> <span class="nv">app</span><span class="o">=</span>postgres <span class="nt">-w</span>
</pre></table></code></div></div><p>Once the new pod is running, check if the data is still there:</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c"># Connect again and check the data</span>
kubectl <span class="nb">exec</span> <span class="nt">-it</span> postgres-0 <span class="nt">--</span> psql <span class="nt">-U</span> rails_user <span class="nt">-d</span> myapp_production <span class="nt">-c</span> <span class="s2">"SELECT * FROM test_persistence;"</span>
</pre></table></code></div></div><p>If you see your test data, you’re all set! Persistent storage is working.</p><h2 id="common-issues-and-solutions"><span class="me-2">Common Issues and Solutions</span><a href="#common-issues-and-solutions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>Permission errors:</strong></p><ul><li>Make sure you’re using <code class="language-plaintext highlighter-rouge">subPath</code> in your volume mount. This is usually the culprit.</ul><p><strong>Storage not persisting:</strong></p><ul><li>Check that the PVC status is <code class="language-plaintext highlighter-rouge">Bound</code> with <code class="language-plaintext highlighter-rouge">kubectl get pvc</code> (if it says “Pending,” the storage wasn’t created)<li>Verify the volume is actually mounted: <code class="language-plaintext highlighter-rouge">kubectl describe pod &lt;pod-name&gt;</code> and look for the mount in the output<li>Make sure you’re using a StatefulSet, not a Deployment. Regular Deployments can lose data when pods restart, even if you attach storage to them. StatefulSets are designed to work with persistent storage.</ul><h2 id="conclusion"><span class="me-2">Conclusion</span><a href="#conclusion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Persistent storage is essential for running databases and other apps that need to remember things in Kubernetes. It adds a bit of complexity compared to simple web apps, but once you understand how PVCs (your storage request), PVs (the actual storage), and StatefulSets (the pods that use the storage) work together, it’s pretty straightforward.</p><h2 id="whats-next"><span class="me-2">What’s Next?</span><a href="#whats-next" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>I’m planning to cover backup and restore strategies for persistent volumes, and how to set up multi-replica databases with persistent storage. Stay tuned!</p><hr /><h2 id="series-navigation"><span class="me-2">Series Navigation</span><a href="#series-navigation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>Part 1:</strong> <a href="/posts/kubernetes-learning-path-deploy-your-first-app/">Deploy Your First App</a><br /> <strong>Part 2:</strong> <a href="/posts/kubernetes-learning-path-configmaps-and-secrets/">ConfigMaps and Secrets</a><br /> <strong>Part 3:</strong> <a href="/posts/kubernetes-learning-path-namespaces/">Understanding Namespaces</a><br /> <strong>Part 4:</strong> <a href="/posts/kubernetes-learning-path-port-mapping/">Understanding Port Mapping in k3d</a><br /> <strong>Part 5:</strong> <a href="/posts/kubernetes-learning-path-k3s-on-raspberry-pi/">Setting Up k3s on Raspberry Pi</a><br /> <strong>Part 6:</strong> Understanding Persistent Storage ← You just finished this!</p><hr /></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/kubernetes/">Kubernetes</a>, <a href="/categories/tutorial/">Tutorial</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/kubernetes/" class="post-tag no-text-decoration" >kubernetes</a> <a href="/tags/persistent-storage/" class="post-tag no-text-decoration" >persistent-storage</a> <a href="/tags/pvc/" class="post-tag no-text-decoration" >pvc</a> <a href="/tags/statefulset/" class="post-tag no-text-decoration" >statefulset</a> <a href="/tags/postgresql/" class="post-tag no-text-decoration" >postgresql</a> <a href="/tags/storage/" class="post-tag no-text-decoration" >storage</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> Thanks for reading! Feel free to share this post with others.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Kubernetes%20Learning%20Path:%20Understanding%20Persistent%20Storage%20-%20Shairyar%20Baig&url=https%3A%2F%2Fshairyar.github.io%2Fposts%2Fkubernetes-learning-path-persistent-storage%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Kubernetes%20Learning%20Path:%20Understanding%20Persistent%20Storage%20-%20Shairyar%20Baig&u=https%3A%2F%2Fshairyar.github.io%2Fposts%2Fkubernetes-learning-path-persistent-storage%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fshairyar.github.io%2Fposts%2Fkubernetes-learning-path-persistent-storage%2F&text=Kubernetes%20Learning%20Path:%20Understanding%20Persistent%20Storage%20-%20Shairyar%20Baig" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/kubernetes-learning-path-persistent-storage/">Kubernetes Learning Path: Understanding Persistent Storage</a><li class="text-truncate lh-lg"> <a href="/posts/remote-access-to-k3s-homelab-with-tailscale/">Remote Access to Your k3s Homelab with Tailscale</a><li class="text-truncate lh-lg"> <a href="/posts/kubernetes-learning-path-rails-solidqueue-on-k3s/">Kubernetes Learning Path: Deploying Rails 8 with SolidQueue on Raspberry Pi k3s</a><li class="text-truncate lh-lg"> <a href="/posts/kubernetes-learning-path-ingress-controller/">Kubernetes Learning Path: Setting Up Ingress Controller for External Access</a><li class="text-truncate lh-lg"> <a href="/posts/kubernetes-learning-path-k3s-on-raspberry-pi/">Kubernetes Learning Path: Setting Up k3s on Raspberry Pi</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag btn btn-outline-primary" href="/tags/k3d/">k3d</a> <a class="post-tag btn btn-outline-primary" href="/tags/k3s/">k3s</a> <a class="post-tag btn btn-outline-primary" href="/tags/deployment/">deployment</a> <a class="post-tag btn btn-outline-primary" href="/tags/raspberry-pi/">raspberry-pi</a> <a class="post-tag btn btn-outline-primary" href="/tags/configmap/">configmap</a> <a class="post-tag btn btn-outline-primary" href="/tags/networking/">networking</a> <a class="post-tag btn btn-outline-primary" href="/tags/postgresql/">postgresql</a> <a class="post-tag btn btn-outline-primary" href="/tags/ruby-on-rails/">ruby-on-rails</a> <a class="post-tag btn btn-outline-primary" href="/tags/docker/">docker</a></div></section></div><div class="toc-border-cover z-3"></div><section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4"><h2 class="panel-heading ps-3 pb-2 mb-0">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/kubernetes-learning-path-rails-solidqueue-on-k3s/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1761901200" data-df="ll" > Oct 31, 2025 </time><h4 class="pt-0 my-2">Kubernetes Learning Path: Deploying Rails 8 with SolidQueue on Raspberry Pi k3s</h4><div class="text-muted"><p>Kubernetes Learning Path: Deploying Rails 8 with SolidQueue on Raspberry Pi k3s After setting up my 3-node Raspberry Pi k3s cluster in the previous post, I wanted to deploy something real—not just...</p></div></div></a></article><article class="col"> <a href="/posts/remote-access-to-k3s-homelab-with-tailscale/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1762664400" data-df="ll" > Nov 9, 2025 </time><h4 class="pt-0 my-2">Remote Access to Your k3s Homelab with Tailscale</h4><div class="text-muted"><p>Remote Access to Your k3s Homelab with Tailscale While working on my k3s homelab cluster, I ran into an interesting challenge: how could I access my cluster when I wasn’t home? I wanted to run kub...</p></div></div></a></article><article class="col"> <a href="/posts/kubernetes-learning-path-ingress-controller/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1762401600" data-df="ll" > Nov 6, 2025 </time><h4 class="pt-0 my-2">Kubernetes Learning Path: Setting Up Ingress Controller for External Access</h4><div class="text-muted"><p>Kubernetes Learning Path: Setting Up Ingress Controller for External Access After deploying my Rails application with PostgreSQL and SolidQueue workers in the previous post, I had a fully function...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/remote-access-to-k3s-homelab-with-tailscale/" class="btn btn-outline-primary" aria-label="Older" ><p>Remote Access to Your k3s Homelab with Tailscale</p></a><div class="btn btn-outline-primary disabled" aria-label="Newer"><p>-</p></div></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2025</time> <a href="https://twitter.com/iamshairyar">Shairyar Baig</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a data-bs-toggle="tooltip" data-bs-placement="top" title="v7.3.1" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag btn btn-outline-primary" href="/tags/k3d/">k3d</a> <a class="post-tag btn btn-outline-primary" href="/tags/k3s/">k3s</a> <a class="post-tag btn btn-outline-primary" href="/tags/deployment/">deployment</a> <a class="post-tag btn btn-outline-primary" href="/tags/raspberry-pi/">raspberry-pi</a> <a class="post-tag btn btn-outline-primary" href="/tags/configmap/">configmap</a> <a class="post-tag btn btn-outline-primary" href="/tags/networking/">networking</a> <a class="post-tag btn btn-outline-primary" href="/tags/postgresql/">postgresql</a> <a class="post-tag btn btn-outline-primary" href="/tags/ruby-on-rails/">ruby-on-rails</a> <a class="post-tag btn btn-outline-primary" href="/tags/docker/">docker</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{content}</p></article>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>
